/*
 * ShipBob Developer API
 *
 * ShipBob Developer API Documentation
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package shipbob

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"reflect"
	"strings"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// OrdersApiService OrdersApi service
type OrdersApiService service

type ApiCancelOrderRequest struct {
	ctx              _context.Context
	ApiService       *OrdersApiService
	orderId          int32
	shipbobChannelId *int32
}

func (r ApiCancelOrderRequest) ShipbobChannelId(shipbobChannelId int32) ApiCancelOrderRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiCancelOrderRequest) Execute() (CanceledOrder, *_nethttp.Response, error) {
	return r.ApiService.CancelOrderExecute(r)
}

/*
 * CancelOrder Cancel single Order by Order ID
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orderId The order ID to cancel
 * @return ApiCancelOrderRequest
 */
func (a *OrdersApiService) CancelOrder(ctx _context.Context, orderId int32) ApiCancelOrderRequest {
	return ApiCancelOrderRequest{
		ApiService: a,
		ctx:        ctx,
		orderId:    orderId,
	}
}

/*
 * Execute executes the request
 * @return CanceledOrder
 */
func (a *OrdersApiService) CancelOrderExecute(r ApiCancelOrderRequest) (CanceledOrder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CanceledOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.CancelOrder")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order/{orderId}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"orderId"+"}", _neturl.PathEscape(parameterToString(r.orderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.shipbobChannelId == nil {
		return localVarReturnValue, nil, reportError("shipbobChannelId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCancelOrderShipmentRequest struct {
	ctx              _context.Context
	ApiService       *OrdersApiService
	shipmentId       int32
	orderId          string
	shipbobChannelId *int32
}

func (r ApiCancelOrderShipmentRequest) ShipbobChannelId(shipbobChannelId int32) ApiCancelOrderShipmentRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiCancelOrderShipmentRequest) Execute() (Shipment, *_nethttp.Response, error) {
	return r.ApiService.CancelOrderShipmentExecute(r)
}

/*
 * CancelOrderShipment Cancel one Shipment by Order Id and Shipment Id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param shipmentId The shipment id to get
 * @param orderId
 * @return ApiCancelOrderShipmentRequest
 */
func (a *OrdersApiService) CancelOrderShipment(ctx _context.Context, shipmentId int32, orderId string) ApiCancelOrderShipmentRequest {
	return ApiCancelOrderShipmentRequest{
		ApiService: a,
		ctx:        ctx,
		shipmentId: shipmentId,
		orderId:    orderId,
	}
}

/*
 * Execute executes the request
 * @return Shipment
 */
func (a *OrdersApiService) CancelOrderShipmentExecute(r ApiCancelOrderShipmentRequest) (Shipment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Shipment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.CancelOrderShipment")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order/{orderId}/shipment/{shipmentId}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", _neturl.PathEscape(parameterToString(r.shipmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"orderId"+"}", _neturl.PathEscape(parameterToString(r.orderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCancelShipmentRequest struct {
	ctx              _context.Context
	ApiService       *OrdersApiService
	shipmentId       int32
	shipbobChannelId *int32
}

func (r ApiCancelShipmentRequest) ShipbobChannelId(shipbobChannelId int32) ApiCancelShipmentRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiCancelShipmentRequest) Execute() (Shipment, *_nethttp.Response, error) {
	return r.ApiService.CancelShipmentExecute(r)
}

/*
 * CancelShipment Cancel one Shipment by Shipment Id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param shipmentId The shipment id to get
 * @return ApiCancelShipmentRequest
 */
func (a *OrdersApiService) CancelShipment(ctx _context.Context, shipmentId int32) ApiCancelShipmentRequest {
	return ApiCancelShipmentRequest{
		ApiService: a,
		ctx:        ctx,
		shipmentId: shipmentId,
	}
}

/*
 * Execute executes the request
 * @return Shipment
 */
func (a *OrdersApiService) CancelShipmentExecute(r ApiCancelShipmentRequest) (Shipment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Shipment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.CancelShipment")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shipment/{shipmentId}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", _neturl.PathEscape(parameterToString(r.shipmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCancelShipmentBulkRequest struct {
	ctx              _context.Context
	ApiService       *OrdersApiService
	shipbobChannelId *int32
	cancelShipment   *CancelShipment
}

func (r ApiCancelShipmentBulkRequest) ShipbobChannelId(shipbobChannelId int32) ApiCancelShipmentBulkRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}
func (r ApiCancelShipmentBulkRequest) CancelShipment(cancelShipment CancelShipment) ApiCancelShipmentBulkRequest {
	r.cancelShipment = &cancelShipment
	return r
}

func (r ApiCancelShipmentBulkRequest) Execute() (InlineResponse200, *_nethttp.Response, error) {
	return r.ApiService.CancelShipmentBulkExecute(r)
}

/*
 * CancelShipmentBulk Cancel multiple Shipments by Shipment Id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCancelShipmentBulkRequest
 */
func (a *OrdersApiService) CancelShipmentBulk(ctx _context.Context) ApiCancelShipmentBulkRequest {
	return ApiCancelShipmentBulkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse200
 */
func (a *OrdersApiService) CancelShipmentBulkExecute(r ApiCancelShipmentBulkRequest) (InlineResponse200, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.CancelShipmentBulk")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shipment/cancelbulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.shipbobChannelId == nil {
		return localVarReturnValue, nil, reportError("shipbobChannelId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	// body params
	localVarPostBody = r.cancelShipment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrderRequest struct {
	ctx              _context.Context
	ApiService       *OrdersApiService
	shipbobChannelId *int32
	createOrder      *CreateOrder
}

func (r ApiCreateOrderRequest) ShipbobChannelId(shipbobChannelId int32) ApiCreateOrderRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}
func (r ApiCreateOrderRequest) CreateOrder(createOrder CreateOrder) ApiCreateOrderRequest {
	r.createOrder = &createOrder
	return r
}

func (r ApiCreateOrderRequest) Execute() (Order, *_nethttp.Response, error) {
	return r.ApiService.CreateOrderExecute(r)
}

/*
 * CreateOrder Create Order
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateOrderRequest
 */
func (a *OrdersApiService) CreateOrder(ctx _context.Context) ApiCreateOrderRequest {
	return ApiCreateOrderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return Order
 */
func (a *OrdersApiService) CreateOrderExecute(r ApiCreateOrderRequest) (Order, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Order
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.CreateOrder")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.shipbobChannelId == nil {
		return localVarReturnValue, nil, reportError("shipbobChannelId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	// body params
	localVarPostBody = r.createOrder
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrderEstimateRequest struct {
	ctx                        _context.Context
	ApiService                 *OrdersApiService
	shipbobChannelId           *int32
	estimateFulfillmentRequest *EstimateFulfillmentRequest
}

func (r ApiCreateOrderEstimateRequest) ShipbobChannelId(shipbobChannelId int32) ApiCreateOrderEstimateRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}
func (r ApiCreateOrderEstimateRequest) EstimateFulfillmentRequest(estimateFulfillmentRequest EstimateFulfillmentRequest) ApiCreateOrderEstimateRequest {
	r.estimateFulfillmentRequest = &estimateFulfillmentRequest
	return r
}

func (r ApiCreateOrderEstimateRequest) Execute() (OrderEstimate, *_nethttp.Response, error) {
	return r.ApiService.CreateOrderEstimateExecute(r)
}

/*
 * CreateOrderEstimate Estimate Fulfillment Cost For Order
 * This endpoint will provide, where possible, an estimate of pricing and fulfillment center assignment of a potential standard (direct to consumer) order. \r\nKeep in mind that there are ways for the merchant to change FC assignment or product configuration after order creation that could invalidate this estimate. \r\nEstimates cannot be returned for items that are unknown, out of stock, or too large for fulfillment using standard box sizes. \r\nAdditional services such as high-pick fees, shipping insurance, auto-splitting or auto-adding items to orders, and signature required are not included in this estimate.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateOrderEstimateRequest
 */
func (a *OrdersApiService) CreateOrderEstimate(ctx _context.Context) ApiCreateOrderEstimateRequest {
	return ApiCreateOrderEstimateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return OrderEstimate
 */
func (a *OrdersApiService) CreateOrderEstimateExecute(r ApiCreateOrderEstimateRequest) (OrderEstimate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OrderEstimate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.CreateOrderEstimate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order/estimate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.shipbobChannelId == nil {
		return localVarReturnValue, nil, reportError("shipbobChannelId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	// body params
	localVarPostBody = r.estimateFulfillmentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderRequest struct {
	ctx              _context.Context
	ApiService       *OrdersApiService
	orderId          int32
	shipbobChannelId *int32
}

func (r ApiGetOrderRequest) ShipbobChannelId(shipbobChannelId int32) ApiGetOrderRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiGetOrderRequest) Execute() (Order, *_nethttp.Response, error) {
	return r.ApiService.GetOrderExecute(r)
}

/*
 * GetOrder Get Order
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orderId
 * @return ApiGetOrderRequest
 */
func (a *OrdersApiService) GetOrder(ctx _context.Context, orderId int32) ApiGetOrderRequest {
	return ApiGetOrderRequest{
		ApiService: a,
		ctx:        ctx,
		orderId:    orderId,
	}
}

/*
 * Execute executes the request
 * @return Order
 */
func (a *OrdersApiService) GetOrderExecute(r ApiGetOrderRequest) (Order, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Order
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.GetOrder")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order/{orderId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orderId"+"}", _neturl.PathEscape(parameterToString(r.orderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderShipmentRequest struct {
	ctx              _context.Context
	ApiService       *OrdersApiService
	orderId          int32
	shipmentId       int32
	shipbobChannelId *int32
}

func (r ApiGetOrderShipmentRequest) ShipbobChannelId(shipbobChannelId int32) ApiGetOrderShipmentRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiGetOrderShipmentRequest) Execute() (Shipment, *_nethttp.Response, error) {
	return r.ApiService.GetOrderShipmentExecute(r)
}

/*
 * GetOrderShipment Get one Shipment by Order Id and Shipment Id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orderId The order id to get the shipment for
 * @param shipmentId The shipment id to get
 * @return ApiGetOrderShipmentRequest
 */
func (a *OrdersApiService) GetOrderShipment(ctx _context.Context, orderId int32, shipmentId int32) ApiGetOrderShipmentRequest {
	return ApiGetOrderShipmentRequest{
		ApiService: a,
		ctx:        ctx,
		orderId:    orderId,
		shipmentId: shipmentId,
	}
}

/*
 * Execute executes the request
 * @return Shipment
 */
func (a *OrdersApiService) GetOrderShipmentExecute(r ApiGetOrderShipmentRequest) (Shipment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Shipment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.GetOrderShipment")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order/{orderId}/shipment/{shipmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orderId"+"}", _neturl.PathEscape(parameterToString(r.orderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", _neturl.PathEscape(parameterToString(r.shipmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderShipmentLogsRequest struct {
	ctx              _context.Context
	ApiService       *OrdersApiService
	orderId          int32
	shipmentId       int32
	shipbobChannelId *int32
}

func (r ApiGetOrderShipmentLogsRequest) ShipbobChannelId(shipbobChannelId int32) ApiGetOrderShipmentLogsRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiGetOrderShipmentLogsRequest) Execute() ([]ShipmentLog, *_nethttp.Response, error) {
	return r.ApiService.GetOrderShipmentLogsExecute(r)
}

/*
 * GetOrderShipmentLogs Get logs for one Shipment by Order Id and Shipment Id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orderId The order id to get the shipment for
 * @param shipmentId The shipment id to get
 * @return ApiGetOrderShipmentLogsRequest
 */
func (a *OrdersApiService) GetOrderShipmentLogs(ctx _context.Context, orderId int32, shipmentId int32) ApiGetOrderShipmentLogsRequest {
	return ApiGetOrderShipmentLogsRequest{
		ApiService: a,
		ctx:        ctx,
		orderId:    orderId,
		shipmentId: shipmentId,
	}
}

/*
 * Execute executes the request
 * @return []ShipmentLog
 */
func (a *OrdersApiService) GetOrderShipmentLogsExecute(r ApiGetOrderShipmentLogsRequest) ([]ShipmentLog, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ShipmentLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.GetOrderShipmentLogs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order/{orderId}/shipment/{shipmentId}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"orderId"+"}", _neturl.PathEscape(parameterToString(r.orderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", _neturl.PathEscape(parameterToString(r.shipmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderShipmentTimelineRequest struct {
	ctx              _context.Context
	ApiService       *OrdersApiService
	orderId          int32
	shipmentId       int32
	shipbobChannelId *int32
}

func (r ApiGetOrderShipmentTimelineRequest) ShipbobChannelId(shipbobChannelId int32) ApiGetOrderShipmentTimelineRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiGetOrderShipmentTimelineRequest) Execute() ([]ShipmentLog, *_nethttp.Response, error) {
	return r.ApiService.GetOrderShipmentTimelineExecute(r)
}

/*
 * GetOrderShipmentTimeline Get one Shipment's status timeline by Order Id and Shipment Id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orderId The order id to get the shipment for
 * @param shipmentId The shipment id to get
 * @return ApiGetOrderShipmentTimelineRequest
 */
func (a *OrdersApiService) GetOrderShipmentTimeline(ctx _context.Context, orderId int32, shipmentId int32) ApiGetOrderShipmentTimelineRequest {
	return ApiGetOrderShipmentTimelineRequest{
		ApiService: a,
		ctx:        ctx,
		orderId:    orderId,
		shipmentId: shipmentId,
	}
}

/*
 * Execute executes the request
 * @return []ShipmentLog
 */
func (a *OrdersApiService) GetOrderShipmentTimelineExecute(r ApiGetOrderShipmentTimelineRequest) ([]ShipmentLog, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ShipmentLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.GetOrderShipmentTimeline")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order/{orderId}/shipment/{shipmentId}/timeline"
	localVarPath = strings.Replace(localVarPath, "{"+"orderId"+"}", _neturl.PathEscape(parameterToString(r.orderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", _neturl.PathEscape(parameterToString(r.shipmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderShipmentsRequest struct {
	ctx              _context.Context
	ApiService       *OrdersApiService
	orderId          int32
	shipbobChannelId *int32
}

func (r ApiGetOrderShipmentsRequest) ShipbobChannelId(shipbobChannelId int32) ApiGetOrderShipmentsRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiGetOrderShipmentsRequest) Execute() ([]Shipment, *_nethttp.Response, error) {
	return r.ApiService.GetOrderShipmentsExecute(r)
}

/*
 * GetOrderShipments Get all Shipments for Order
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orderId The order id to get shipments for
 * @return ApiGetOrderShipmentsRequest
 */
func (a *OrdersApiService) GetOrderShipments(ctx _context.Context, orderId int32) ApiGetOrderShipmentsRequest {
	return ApiGetOrderShipmentsRequest{
		ApiService: a,
		ctx:        ctx,
		orderId:    orderId,
	}
}

/*
 * Execute executes the request
 * @return []Shipment
 */
func (a *OrdersApiService) GetOrderShipmentsExecute(r ApiGetOrderShipmentsRequest) ([]Shipment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Shipment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.GetOrderShipments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order/{orderId}/shipment"
	localVarPath = strings.Replace(localVarPath, "{"+"orderId"+"}", _neturl.PathEscape(parameterToString(r.orderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrdersRequest struct {
	ctx                 _context.Context
	ApiService          *OrdersApiService
	page                *int32
	limit               *int32
	iDs                 *[]int32
	referenceIds        *[]string
	startDate           *time.Time
	endDate             *time.Time
	sortOrder           *string
	hasTracking         *bool
	lastUpdateStartDate *time.Time
	lastUpdateEndDate   *time.Time
	shipbobChannelId    *int32
}

func (r ApiGetOrdersRequest) Page(page int32) ApiGetOrdersRequest {
	r.page = &page
	return r
}
func (r ApiGetOrdersRequest) Limit(limit int32) ApiGetOrdersRequest {
	r.limit = &limit
	return r
}
func (r ApiGetOrdersRequest) IDs(iDs []int32) ApiGetOrdersRequest {
	r.iDs = &iDs
	return r
}
func (r ApiGetOrdersRequest) ReferenceIds(referenceIds []string) ApiGetOrdersRequest {
	r.referenceIds = &referenceIds
	return r
}
func (r ApiGetOrdersRequest) StartDate(startDate time.Time) ApiGetOrdersRequest {
	r.startDate = &startDate
	return r
}
func (r ApiGetOrdersRequest) EndDate(endDate time.Time) ApiGetOrdersRequest {
	r.endDate = &endDate
	return r
}
func (r ApiGetOrdersRequest) SortOrder(sortOrder string) ApiGetOrdersRequest {
	r.sortOrder = &sortOrder
	return r
}
func (r ApiGetOrdersRequest) HasTracking(hasTracking bool) ApiGetOrdersRequest {
	r.hasTracking = &hasTracking
	return r
}
func (r ApiGetOrdersRequest) LastUpdateStartDate(lastUpdateStartDate time.Time) ApiGetOrdersRequest {
	r.lastUpdateStartDate = &lastUpdateStartDate
	return r
}
func (r ApiGetOrdersRequest) LastUpdateEndDate(lastUpdateEndDate time.Time) ApiGetOrdersRequest {
	r.lastUpdateEndDate = &lastUpdateEndDate
	return r
}
func (r ApiGetOrdersRequest) ShipbobChannelId(shipbobChannelId int32) ApiGetOrdersRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiGetOrdersRequest) Execute() ([]Order, *_nethttp.Response, error) {
	return r.ApiService.GetOrdersExecute(r)
}

/*
 * GetOrders Get Orders
 * All parameters are AND filters
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetOrdersRequest
 */
func (a *OrdersApiService) GetOrders(ctx _context.Context) ApiGetOrdersRequest {
	return ApiGetOrdersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []Order
 */
func (a *OrdersApiService) GetOrdersExecute(r ApiGetOrdersRequest) ([]Order, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Order
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.GetOrders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("Page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("Limit", parameterToString(*r.limit, ""))
	}
	if r.iDs != nil {
		t := *r.iDs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("IDs", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("IDs", parameterToString(t, "multi"))
		}
	}
	if r.referenceIds != nil {
		t := *r.referenceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("ReferenceIds", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("ReferenceIds", parameterToString(t, "multi"))
		}
	}
	if r.startDate != nil {
		localVarQueryParams.Add("StartDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("EndDate", parameterToString(*r.endDate, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("SortOrder", parameterToString(*r.sortOrder, ""))
	}
	if r.hasTracking != nil {
		localVarQueryParams.Add("HasTracking", parameterToString(*r.hasTracking, ""))
	}
	if r.lastUpdateStartDate != nil {
		localVarQueryParams.Add("LastUpdateStartDate", parameterToString(*r.lastUpdateStartDate, ""))
	}
	if r.lastUpdateEndDate != nil {
		localVarQueryParams.Add("LastUpdateEndDate", parameterToString(*r.lastUpdateEndDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetShipmentRequest struct {
	ctx              _context.Context
	ApiService       *OrdersApiService
	shipmentId       int32
	shipbobChannelId *int32
}

func (r ApiGetShipmentRequest) ShipbobChannelId(shipbobChannelId int32) ApiGetShipmentRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiGetShipmentRequest) Execute() (Shipment, *_nethttp.Response, error) {
	return r.ApiService.GetShipmentExecute(r)
}

/*
 * GetShipment Get one Shipment by Shipment Id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param shipmentId The shipment id to get
 * @return ApiGetShipmentRequest
 */
func (a *OrdersApiService) GetShipment(ctx _context.Context, shipmentId int32) ApiGetShipmentRequest {
	return ApiGetShipmentRequest{
		ApiService: a,
		ctx:        ctx,
		shipmentId: shipmentId,
	}
}

/*
 * Execute executes the request
 * @return Shipment
 */
func (a *OrdersApiService) GetShipmentExecute(r ApiGetShipmentRequest) (Shipment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Shipment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.GetShipment")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shipment/{shipmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", _neturl.PathEscape(parameterToString(r.shipmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetShipmentLogsRequest struct {
	ctx              _context.Context
	ApiService       *OrdersApiService
	shipmentId       int32
	shipbobChannelId *int32
}

func (r ApiGetShipmentLogsRequest) ShipbobChannelId(shipbobChannelId int32) ApiGetShipmentLogsRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiGetShipmentLogsRequest) Execute() ([]ShipmentLog, *_nethttp.Response, error) {
	return r.ApiService.GetShipmentLogsExecute(r)
}

/*
 * GetShipmentLogs Get logs for one Shipment by Shipment Id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param shipmentId The shipment id to get
 * @return ApiGetShipmentLogsRequest
 */
func (a *OrdersApiService) GetShipmentLogs(ctx _context.Context, shipmentId int32) ApiGetShipmentLogsRequest {
	return ApiGetShipmentLogsRequest{
		ApiService: a,
		ctx:        ctx,
		shipmentId: shipmentId,
	}
}

/*
 * Execute executes the request
 * @return []ShipmentLog
 */
func (a *OrdersApiService) GetShipmentLogsExecute(r ApiGetShipmentLogsRequest) ([]ShipmentLog, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ShipmentLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.GetShipmentLogs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shipment/{shipmentId}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", _neturl.PathEscape(parameterToString(r.shipmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetShipmentTimelineRequest struct {
	ctx              _context.Context
	ApiService       *OrdersApiService
	shipmentId       int32
	shipbobChannelId *int32
}

func (r ApiGetShipmentTimelineRequest) ShipbobChannelId(shipbobChannelId int32) ApiGetShipmentTimelineRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiGetShipmentTimelineRequest) Execute() ([]ShipmentLog, *_nethttp.Response, error) {
	return r.ApiService.GetShipmentTimelineExecute(r)
}

/*
 * GetShipmentTimeline Get one Shipment's status timeline by Shipment Id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param shipmentId The shipment id to get
 * @return ApiGetShipmentTimelineRequest
 */
func (a *OrdersApiService) GetShipmentTimeline(ctx _context.Context, shipmentId int32) ApiGetShipmentTimelineRequest {
	return ApiGetShipmentTimelineRequest{
		ApiService: a,
		ctx:        ctx,
		shipmentId: shipmentId,
	}
}

/*
 * Execute executes the request
 * @return []ShipmentLog
 */
func (a *OrdersApiService) GetShipmentTimelineExecute(r ApiGetShipmentTimelineRequest) ([]ShipmentLog, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ShipmentLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.GetShipmentTimeline")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shipment/{shipmentId}/timeline"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", _neturl.PathEscape(parameterToString(r.shipmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetShippingMethodCollectionRequest struct {
	ctx        _context.Context
	ApiService *OrdersApiService
	page       *int32
	limit      *int32
}

func (r ApiGetShippingMethodCollectionRequest) Page(page int32) ApiGetShippingMethodCollectionRequest {
	r.page = &page
	return r
}
func (r ApiGetShippingMethodCollectionRequest) Limit(limit int32) ApiGetShippingMethodCollectionRequest {
	r.limit = &limit
	return r
}

func (r ApiGetShippingMethodCollectionRequest) Execute() ([]ShipMethodDetail, *_nethttp.Response, error) {
	return r.ApiService.GetShippingMethodCollectionExecute(r)
}

/*
 * GetShippingMethodCollection Get shipping methods
 * Get all merchants shipping methods
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetShippingMethodCollectionRequest
 */
func (a *OrdersApiService) GetShippingMethodCollection(ctx _context.Context) ApiGetShippingMethodCollectionRequest {
	return ApiGetShippingMethodCollectionRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []ShipMethodDetail
 */
func (a *OrdersApiService) GetShippingMethodCollectionExecute(r ApiGetShippingMethodCollectionRequest) ([]ShipMethodDetail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ShipMethodDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.GetShippingMethodCollection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shippingmethod"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("Page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("Limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

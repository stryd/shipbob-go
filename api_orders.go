/*
 * ShipBob Developer API
 *
 * ShipBob Developer API Documentation
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package shipbob

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// OrdersApiService OrdersApi service
type OrdersApiService service

type ApiOrderEstimatePostRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	shipbobChannelId *int32
	shipBobOrdersPresentationModelsEstimateFulfillmentRequestModel *ShipBobOrdersPresentationModelsEstimateFulfillmentRequestModel
}

func (r ApiOrderEstimatePostRequest) ShipbobChannelId(shipbobChannelId int32) ApiOrderEstimatePostRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}
func (r ApiOrderEstimatePostRequest) ShipBobOrdersPresentationModelsEstimateFulfillmentRequestModel(shipBobOrdersPresentationModelsEstimateFulfillmentRequestModel ShipBobOrdersPresentationModelsEstimateFulfillmentRequestModel) ApiOrderEstimatePostRequest {
	r.shipBobOrdersPresentationModelsEstimateFulfillmentRequestModel = &shipBobOrdersPresentationModelsEstimateFulfillmentRequestModel
	return r
}

func (r ApiOrderEstimatePostRequest) Execute() (ShipBobOrdersPresentationViewModelsEstimateViewModel, *_nethttp.Response, error) {
	return r.ApiService.OrderEstimatePostExecute(r)
}

/*
 * OrderEstimatePost Estimate Fulfillment Cost For Order
 * This endpoint will provide, where possible, an estimate of pricing and fulfillment center assignment of a potential standard (direct to consumer) order. \r\nKeep in mind that there are ways for the merchant to change FC assignment or product configuration after order creation that could invalidate this estimate. \r\nEstimates cannot be returned for items that are unknown, out of stock, or too large for fulfillment using standard box sizes. \r\nAdditional services such as high-pick fees, shipping insurance, auto-splitting or auto-adding items to orders, and signature required are not included in this estimate.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiOrderEstimatePostRequest
 */
func (a *OrdersApiService) OrderEstimatePost(ctx _context.Context) ApiOrderEstimatePostRequest {
	return ApiOrderEstimatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ShipBobOrdersPresentationViewModelsEstimateViewModel
 */
func (a *OrdersApiService) OrderEstimatePostExecute(r ApiOrderEstimatePostRequest) (ShipBobOrdersPresentationViewModelsEstimateViewModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ShipBobOrdersPresentationViewModelsEstimateViewModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.OrderEstimatePost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order/estimate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.shipbobChannelId == nil {
		return localVarReturnValue, nil, reportError("shipbobChannelId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/_*+json", "application/json", "application/json-patch+json", "text/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	// body params
	localVarPostBody = r.shipBobOrdersPresentationModelsEstimateFulfillmentRequestModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderGetRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	page *int32
	limit *int32
	iDs *[]int32
	referenceIds *[]string
	startDate *time.Time
	endDate *time.Time
	sortOrder *string
	hasTracking *bool
	lastUpdateStartDate *time.Time
	lastUpdateEndDate *time.Time
	shipbobChannelId *int32
}

func (r ApiOrderGetRequest) Page(page int32) ApiOrderGetRequest {
	r.page = &page
	return r
}
func (r ApiOrderGetRequest) Limit(limit int32) ApiOrderGetRequest {
	r.limit = &limit
	return r
}
func (r ApiOrderGetRequest) IDs(iDs []int32) ApiOrderGetRequest {
	r.iDs = &iDs
	return r
}
func (r ApiOrderGetRequest) ReferenceIds(referenceIds []string) ApiOrderGetRequest {
	r.referenceIds = &referenceIds
	return r
}
func (r ApiOrderGetRequest) StartDate(startDate time.Time) ApiOrderGetRequest {
	r.startDate = &startDate
	return r
}
func (r ApiOrderGetRequest) EndDate(endDate time.Time) ApiOrderGetRequest {
	r.endDate = &endDate
	return r
}
func (r ApiOrderGetRequest) SortOrder(sortOrder string) ApiOrderGetRequest {
	r.sortOrder = &sortOrder
	return r
}
func (r ApiOrderGetRequest) HasTracking(hasTracking bool) ApiOrderGetRequest {
	r.hasTracking = &hasTracking
	return r
}
func (r ApiOrderGetRequest) LastUpdateStartDate(lastUpdateStartDate time.Time) ApiOrderGetRequest {
	r.lastUpdateStartDate = &lastUpdateStartDate
	return r
}
func (r ApiOrderGetRequest) LastUpdateEndDate(lastUpdateEndDate time.Time) ApiOrderGetRequest {
	r.lastUpdateEndDate = &lastUpdateEndDate
	return r
}
func (r ApiOrderGetRequest) ShipbobChannelId(shipbobChannelId int32) ApiOrderGetRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiOrderGetRequest) Execute() ([]ShipBobOrdersPresentationViewModelsOrderViewModel, *_nethttp.Response, error) {
	return r.ApiService.OrderGetExecute(r)
}

/*
 * OrderGet Get Orders
 * All parameters are AND filters
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiOrderGetRequest
 */
func (a *OrdersApiService) OrderGet(ctx _context.Context) ApiOrderGetRequest {
	return ApiOrderGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []ShipBobOrdersPresentationViewModelsOrderViewModel
 */
func (a *OrdersApiService) OrderGetExecute(r ApiOrderGetRequest) ([]ShipBobOrdersPresentationViewModelsOrderViewModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ShipBobOrdersPresentationViewModelsOrderViewModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.OrderGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("Page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("Limit", parameterToString(*r.limit, ""))
	}
	if r.iDs != nil {
		t := *r.iDs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("IDs", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("IDs", parameterToString(t, "multi"))
		}
	}
	if r.referenceIds != nil {
		t := *r.referenceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("ReferenceIds", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("ReferenceIds", parameterToString(t, "multi"))
		}
	}
	if r.startDate != nil {
		localVarQueryParams.Add("StartDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("EndDate", parameterToString(*r.endDate, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("SortOrder", parameterToString(*r.sortOrder, ""))
	}
	if r.hasTracking != nil {
		localVarQueryParams.Add("HasTracking", parameterToString(*r.hasTracking, ""))
	}
	if r.lastUpdateStartDate != nil {
		localVarQueryParams.Add("LastUpdateStartDate", parameterToString(*r.lastUpdateStartDate, ""))
	}
	if r.lastUpdateEndDate != nil {
		localVarQueryParams.Add("LastUpdateEndDate", parameterToString(*r.lastUpdateEndDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderOrderIdCancelPostRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	orderId int32
	shipbobChannelId *int32
}

func (r ApiOrderOrderIdCancelPostRequest) ShipbobChannelId(shipbobChannelId int32) ApiOrderOrderIdCancelPostRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiOrderOrderIdCancelPostRequest) Execute() (ShipBobOrdersPresentationViewModelsCanceledOrderViewModel, *_nethttp.Response, error) {
	return r.ApiService.OrderOrderIdCancelPostExecute(r)
}

/*
 * OrderOrderIdCancelPost Cancel single Order by Order ID
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orderId The order ID to cancel
 * @return ApiOrderOrderIdCancelPostRequest
 */
func (a *OrdersApiService) OrderOrderIdCancelPost(ctx _context.Context, orderId int32) ApiOrderOrderIdCancelPostRequest {
	return ApiOrderOrderIdCancelPostRequest{
		ApiService: a,
		ctx: ctx,
		orderId: orderId,
	}
}

/*
 * Execute executes the request
 * @return ShipBobOrdersPresentationViewModelsCanceledOrderViewModel
 */
func (a *OrdersApiService) OrderOrderIdCancelPostExecute(r ApiOrderOrderIdCancelPostRequest) (ShipBobOrdersPresentationViewModelsCanceledOrderViewModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ShipBobOrdersPresentationViewModelsCanceledOrderViewModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.OrderOrderIdCancelPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order/{orderId}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"orderId"+"}", _neturl.PathEscape(parameterToString(r.orderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.shipbobChannelId == nil {
		return localVarReturnValue, nil, reportError("shipbobChannelId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderOrderIdGetRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	orderId int32
	shipbobChannelId *int32
}

func (r ApiOrderOrderIdGetRequest) ShipbobChannelId(shipbobChannelId int32) ApiOrderOrderIdGetRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiOrderOrderIdGetRequest) Execute() (ShipBobOrdersPresentationViewModelsOrderViewModel, *_nethttp.Response, error) {
	return r.ApiService.OrderOrderIdGetExecute(r)
}

/*
 * OrderOrderIdGet Get Order
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orderId
 * @return ApiOrderOrderIdGetRequest
 */
func (a *OrdersApiService) OrderOrderIdGet(ctx _context.Context, orderId int32) ApiOrderOrderIdGetRequest {
	return ApiOrderOrderIdGetRequest{
		ApiService: a,
		ctx: ctx,
		orderId: orderId,
	}
}

/*
 * Execute executes the request
 * @return ShipBobOrdersPresentationViewModelsOrderViewModel
 */
func (a *OrdersApiService) OrderOrderIdGetExecute(r ApiOrderOrderIdGetRequest) (ShipBobOrdersPresentationViewModelsOrderViewModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ShipBobOrdersPresentationViewModelsOrderViewModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.OrderOrderIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order/{orderId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orderId"+"}", _neturl.PathEscape(parameterToString(r.orderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderOrderIdShipmentGetRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	orderId int32
	shipbobChannelId *int32
}

func (r ApiOrderOrderIdShipmentGetRequest) ShipbobChannelId(shipbobChannelId int32) ApiOrderOrderIdShipmentGetRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiOrderOrderIdShipmentGetRequest) Execute() ([]ShipBobOrdersPresentationViewModelsShipmentViewModel, *_nethttp.Response, error) {
	return r.ApiService.OrderOrderIdShipmentGetExecute(r)
}

/*
 * OrderOrderIdShipmentGet Get all Shipments for Order
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orderId The order id to get shipments for
 * @return ApiOrderOrderIdShipmentGetRequest
 */
func (a *OrdersApiService) OrderOrderIdShipmentGet(ctx _context.Context, orderId int32) ApiOrderOrderIdShipmentGetRequest {
	return ApiOrderOrderIdShipmentGetRequest{
		ApiService: a,
		ctx: ctx,
		orderId: orderId,
	}
}

/*
 * Execute executes the request
 * @return []ShipBobOrdersPresentationViewModelsShipmentViewModel
 */
func (a *OrdersApiService) OrderOrderIdShipmentGetExecute(r ApiOrderOrderIdShipmentGetRequest) ([]ShipBobOrdersPresentationViewModelsShipmentViewModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ShipBobOrdersPresentationViewModelsShipmentViewModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.OrderOrderIdShipmentGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order/{orderId}/shipment"
	localVarPath = strings.Replace(localVarPath, "{"+"orderId"+"}", _neturl.PathEscape(parameterToString(r.orderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderOrderIdShipmentShipmentIdCancelPostRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	shipmentId int32
	orderId string
	shipbobChannelId *int32
}

func (r ApiOrderOrderIdShipmentShipmentIdCancelPostRequest) ShipbobChannelId(shipbobChannelId int32) ApiOrderOrderIdShipmentShipmentIdCancelPostRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiOrderOrderIdShipmentShipmentIdCancelPostRequest) Execute() (ShipBobOrdersPresentationViewModelsShipmentViewModel, *_nethttp.Response, error) {
	return r.ApiService.OrderOrderIdShipmentShipmentIdCancelPostExecute(r)
}

/*
 * OrderOrderIdShipmentShipmentIdCancelPost Cancel one Shipment by Order Id and Shipment Id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param shipmentId The shipment id to get
 * @param orderId
 * @return ApiOrderOrderIdShipmentShipmentIdCancelPostRequest
 */
func (a *OrdersApiService) OrderOrderIdShipmentShipmentIdCancelPost(ctx _context.Context, shipmentId int32, orderId string) ApiOrderOrderIdShipmentShipmentIdCancelPostRequest {
	return ApiOrderOrderIdShipmentShipmentIdCancelPostRequest{
		ApiService: a,
		ctx: ctx,
		shipmentId: shipmentId,
		orderId: orderId,
	}
}

/*
 * Execute executes the request
 * @return ShipBobOrdersPresentationViewModelsShipmentViewModel
 */
func (a *OrdersApiService) OrderOrderIdShipmentShipmentIdCancelPostExecute(r ApiOrderOrderIdShipmentShipmentIdCancelPostRequest) (ShipBobOrdersPresentationViewModelsShipmentViewModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ShipBobOrdersPresentationViewModelsShipmentViewModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.OrderOrderIdShipmentShipmentIdCancelPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order/{orderId}/shipment/{shipmentId}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", _neturl.PathEscape(parameterToString(r.shipmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"orderId"+"}", _neturl.PathEscape(parameterToString(r.orderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderOrderIdShipmentShipmentIdGetRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	orderId int32
	shipmentId int32
	shipbobChannelId *int32
}

func (r ApiOrderOrderIdShipmentShipmentIdGetRequest) ShipbobChannelId(shipbobChannelId int32) ApiOrderOrderIdShipmentShipmentIdGetRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiOrderOrderIdShipmentShipmentIdGetRequest) Execute() (ShipBobOrdersPresentationViewModelsShipmentViewModel, *_nethttp.Response, error) {
	return r.ApiService.OrderOrderIdShipmentShipmentIdGetExecute(r)
}

/*
 * OrderOrderIdShipmentShipmentIdGet Get one Shipment by Order Id and Shipment Id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orderId The order id to get the shipment for
 * @param shipmentId The shipment id to get
 * @return ApiOrderOrderIdShipmentShipmentIdGetRequest
 */
func (a *OrdersApiService) OrderOrderIdShipmentShipmentIdGet(ctx _context.Context, orderId int32, shipmentId int32) ApiOrderOrderIdShipmentShipmentIdGetRequest {
	return ApiOrderOrderIdShipmentShipmentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		orderId: orderId,
		shipmentId: shipmentId,
	}
}

/*
 * Execute executes the request
 * @return ShipBobOrdersPresentationViewModelsShipmentViewModel
 */
func (a *OrdersApiService) OrderOrderIdShipmentShipmentIdGetExecute(r ApiOrderOrderIdShipmentShipmentIdGetRequest) (ShipBobOrdersPresentationViewModelsShipmentViewModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ShipBobOrdersPresentationViewModelsShipmentViewModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.OrderOrderIdShipmentShipmentIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order/{orderId}/shipment/{shipmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orderId"+"}", _neturl.PathEscape(parameterToString(r.orderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", _neturl.PathEscape(parameterToString(r.shipmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderOrderIdShipmentShipmentIdLogsGetRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	orderId int32
	shipmentId int32
	shipbobChannelId *int32
}

func (r ApiOrderOrderIdShipmentShipmentIdLogsGetRequest) ShipbobChannelId(shipbobChannelId int32) ApiOrderOrderIdShipmentShipmentIdLogsGetRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiOrderOrderIdShipmentShipmentIdLogsGetRequest) Execute() ([]ShipBobOrdersPresentationViewModelsShipmentLogViewModel, *_nethttp.Response, error) {
	return r.ApiService.OrderOrderIdShipmentShipmentIdLogsGetExecute(r)
}

/*
 * OrderOrderIdShipmentShipmentIdLogsGet Get logs for one Shipment by Order Id and Shipment Id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orderId The order id to get the shipment for
 * @param shipmentId The shipment id to get
 * @return ApiOrderOrderIdShipmentShipmentIdLogsGetRequest
 */
func (a *OrdersApiService) OrderOrderIdShipmentShipmentIdLogsGet(ctx _context.Context, orderId int32, shipmentId int32) ApiOrderOrderIdShipmentShipmentIdLogsGetRequest {
	return ApiOrderOrderIdShipmentShipmentIdLogsGetRequest{
		ApiService: a,
		ctx: ctx,
		orderId: orderId,
		shipmentId: shipmentId,
	}
}

/*
 * Execute executes the request
 * @return []ShipBobOrdersPresentationViewModelsShipmentLogViewModel
 */
func (a *OrdersApiService) OrderOrderIdShipmentShipmentIdLogsGetExecute(r ApiOrderOrderIdShipmentShipmentIdLogsGetRequest) ([]ShipBobOrdersPresentationViewModelsShipmentLogViewModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ShipBobOrdersPresentationViewModelsShipmentLogViewModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.OrderOrderIdShipmentShipmentIdLogsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order/{orderId}/shipment/{shipmentId}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"orderId"+"}", _neturl.PathEscape(parameterToString(r.orderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", _neturl.PathEscape(parameterToString(r.shipmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderOrderIdShipmentShipmentIdTimelineGetRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	orderId int32
	shipmentId int32
	shipbobChannelId *int32
}

func (r ApiOrderOrderIdShipmentShipmentIdTimelineGetRequest) ShipbobChannelId(shipbobChannelId int32) ApiOrderOrderIdShipmentShipmentIdTimelineGetRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiOrderOrderIdShipmentShipmentIdTimelineGetRequest) Execute() ([]ShipBobOrdersPresentationViewModelsShipmentLogViewModel, *_nethttp.Response, error) {
	return r.ApiService.OrderOrderIdShipmentShipmentIdTimelineGetExecute(r)
}

/*
 * OrderOrderIdShipmentShipmentIdTimelineGet Get one Shipment's status timeline by Order Id and Shipment Id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orderId The order id to get the shipment for
 * @param shipmentId The shipment id to get
 * @return ApiOrderOrderIdShipmentShipmentIdTimelineGetRequest
 */
func (a *OrdersApiService) OrderOrderIdShipmentShipmentIdTimelineGet(ctx _context.Context, orderId int32, shipmentId int32) ApiOrderOrderIdShipmentShipmentIdTimelineGetRequest {
	return ApiOrderOrderIdShipmentShipmentIdTimelineGetRequest{
		ApiService: a,
		ctx: ctx,
		orderId: orderId,
		shipmentId: shipmentId,
	}
}

/*
 * Execute executes the request
 * @return []ShipBobOrdersPresentationViewModelsShipmentLogViewModel
 */
func (a *OrdersApiService) OrderOrderIdShipmentShipmentIdTimelineGetExecute(r ApiOrderOrderIdShipmentShipmentIdTimelineGetRequest) ([]ShipBobOrdersPresentationViewModelsShipmentLogViewModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ShipBobOrdersPresentationViewModelsShipmentLogViewModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.OrderOrderIdShipmentShipmentIdTimelineGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order/{orderId}/shipment/{shipmentId}/timeline"
	localVarPath = strings.Replace(localVarPath, "{"+"orderId"+"}", _neturl.PathEscape(parameterToString(r.orderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", _neturl.PathEscape(parameterToString(r.shipmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderPostRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	shipbobChannelId *int32
	shipBobOrdersPresentationModelsCreateOrderModel *ShipBobOrdersPresentationModelsCreateOrderModel
}

func (r ApiOrderPostRequest) ShipbobChannelId(shipbobChannelId int32) ApiOrderPostRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}
func (r ApiOrderPostRequest) ShipBobOrdersPresentationModelsCreateOrderModel(shipBobOrdersPresentationModelsCreateOrderModel ShipBobOrdersPresentationModelsCreateOrderModel) ApiOrderPostRequest {
	r.shipBobOrdersPresentationModelsCreateOrderModel = &shipBobOrdersPresentationModelsCreateOrderModel
	return r
}

func (r ApiOrderPostRequest) Execute() (ShipBobOrdersPresentationViewModelsOrderViewModel, *_nethttp.Response, error) {
	return r.ApiService.OrderPostExecute(r)
}

/*
 * OrderPost Create Order
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiOrderPostRequest
 */
func (a *OrdersApiService) OrderPost(ctx _context.Context) ApiOrderPostRequest {
	return ApiOrderPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ShipBobOrdersPresentationViewModelsOrderViewModel
 */
func (a *OrdersApiService) OrderPostExecute(r ApiOrderPostRequest) (ShipBobOrdersPresentationViewModelsOrderViewModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ShipBobOrdersPresentationViewModelsOrderViewModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.OrderPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.shipbobChannelId == nil {
		return localVarReturnValue, nil, reportError("shipbobChannelId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/_*+json", "application/json", "application/json-patch+json", "text/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	// body params
	localVarPostBody = r.shipBobOrdersPresentationModelsCreateOrderModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShipmentCancelbulkPostRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	shipbobChannelId *int32
	shipBobOrdersPresentationModelsCancelShipmentsModel *ShipBobOrdersPresentationModelsCancelShipmentsModel
}

func (r ApiShipmentCancelbulkPostRequest) ShipbobChannelId(shipbobChannelId int32) ApiShipmentCancelbulkPostRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}
func (r ApiShipmentCancelbulkPostRequest) ShipBobOrdersPresentationModelsCancelShipmentsModel(shipBobOrdersPresentationModelsCancelShipmentsModel ShipBobOrdersPresentationModelsCancelShipmentsModel) ApiShipmentCancelbulkPostRequest {
	r.shipBobOrdersPresentationModelsCancelShipmentsModel = &shipBobOrdersPresentationModelsCancelShipmentsModel
	return r
}

func (r ApiShipmentCancelbulkPostRequest) Execute() (ShipBobOrdersPresentationViewModelsCanceledShipmentsViewModel, *_nethttp.Response, error) {
	return r.ApiService.ShipmentCancelbulkPostExecute(r)
}

/*
 * ShipmentCancelbulkPost Cancel multiple Shipments by Shipment Id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiShipmentCancelbulkPostRequest
 */
func (a *OrdersApiService) ShipmentCancelbulkPost(ctx _context.Context) ApiShipmentCancelbulkPostRequest {
	return ApiShipmentCancelbulkPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ShipBobOrdersPresentationViewModelsCanceledShipmentsViewModel
 */
func (a *OrdersApiService) ShipmentCancelbulkPostExecute(r ApiShipmentCancelbulkPostRequest) (ShipBobOrdersPresentationViewModelsCanceledShipmentsViewModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ShipBobOrdersPresentationViewModelsCanceledShipmentsViewModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.ShipmentCancelbulkPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shipment/cancelbulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.shipbobChannelId == nil {
		return localVarReturnValue, nil, reportError("shipbobChannelId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/_*+json", "application/json", "application/json-patch+json", "text/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	// body params
	localVarPostBody = r.shipBobOrdersPresentationModelsCancelShipmentsModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShipmentShipmentIdCancelPostRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	shipmentId int32
	shipbobChannelId *int32
}

func (r ApiShipmentShipmentIdCancelPostRequest) ShipbobChannelId(shipbobChannelId int32) ApiShipmentShipmentIdCancelPostRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiShipmentShipmentIdCancelPostRequest) Execute() (ShipBobOrdersPresentationViewModelsShipmentViewModel, *_nethttp.Response, error) {
	return r.ApiService.ShipmentShipmentIdCancelPostExecute(r)
}

/*
 * ShipmentShipmentIdCancelPost Cancel one Shipment by Shipment Id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param shipmentId The shipment id to get
 * @return ApiShipmentShipmentIdCancelPostRequest
 */
func (a *OrdersApiService) ShipmentShipmentIdCancelPost(ctx _context.Context, shipmentId int32) ApiShipmentShipmentIdCancelPostRequest {
	return ApiShipmentShipmentIdCancelPostRequest{
		ApiService: a,
		ctx: ctx,
		shipmentId: shipmentId,
	}
}

/*
 * Execute executes the request
 * @return ShipBobOrdersPresentationViewModelsShipmentViewModel
 */
func (a *OrdersApiService) ShipmentShipmentIdCancelPostExecute(r ApiShipmentShipmentIdCancelPostRequest) (ShipBobOrdersPresentationViewModelsShipmentViewModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ShipBobOrdersPresentationViewModelsShipmentViewModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.ShipmentShipmentIdCancelPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shipment/{shipmentId}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", _neturl.PathEscape(parameterToString(r.shipmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShipmentShipmentIdGetRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	shipmentId int32
	shipbobChannelId *int32
}

func (r ApiShipmentShipmentIdGetRequest) ShipbobChannelId(shipbobChannelId int32) ApiShipmentShipmentIdGetRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiShipmentShipmentIdGetRequest) Execute() (ShipBobOrdersPresentationViewModelsShipmentViewModel, *_nethttp.Response, error) {
	return r.ApiService.ShipmentShipmentIdGetExecute(r)
}

/*
 * ShipmentShipmentIdGet Get one Shipment by Shipment Id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param shipmentId The shipment id to get
 * @return ApiShipmentShipmentIdGetRequest
 */
func (a *OrdersApiService) ShipmentShipmentIdGet(ctx _context.Context, shipmentId int32) ApiShipmentShipmentIdGetRequest {
	return ApiShipmentShipmentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		shipmentId: shipmentId,
	}
}

/*
 * Execute executes the request
 * @return ShipBobOrdersPresentationViewModelsShipmentViewModel
 */
func (a *OrdersApiService) ShipmentShipmentIdGetExecute(r ApiShipmentShipmentIdGetRequest) (ShipBobOrdersPresentationViewModelsShipmentViewModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ShipBobOrdersPresentationViewModelsShipmentViewModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.ShipmentShipmentIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shipment/{shipmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", _neturl.PathEscape(parameterToString(r.shipmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShipmentShipmentIdLogsGetRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	shipmentId int32
	shipbobChannelId *int32
}

func (r ApiShipmentShipmentIdLogsGetRequest) ShipbobChannelId(shipbobChannelId int32) ApiShipmentShipmentIdLogsGetRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiShipmentShipmentIdLogsGetRequest) Execute() ([]ShipBobOrdersPresentationViewModelsShipmentLogViewModel, *_nethttp.Response, error) {
	return r.ApiService.ShipmentShipmentIdLogsGetExecute(r)
}

/*
 * ShipmentShipmentIdLogsGet Get logs for one Shipment by Shipment Id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param shipmentId The shipment id to get
 * @return ApiShipmentShipmentIdLogsGetRequest
 */
func (a *OrdersApiService) ShipmentShipmentIdLogsGet(ctx _context.Context, shipmentId int32) ApiShipmentShipmentIdLogsGetRequest {
	return ApiShipmentShipmentIdLogsGetRequest{
		ApiService: a,
		ctx: ctx,
		shipmentId: shipmentId,
	}
}

/*
 * Execute executes the request
 * @return []ShipBobOrdersPresentationViewModelsShipmentLogViewModel
 */
func (a *OrdersApiService) ShipmentShipmentIdLogsGetExecute(r ApiShipmentShipmentIdLogsGetRequest) ([]ShipBobOrdersPresentationViewModelsShipmentLogViewModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ShipBobOrdersPresentationViewModelsShipmentLogViewModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.ShipmentShipmentIdLogsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shipment/{shipmentId}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", _neturl.PathEscape(parameterToString(r.shipmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShipmentShipmentIdTimelineGetRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	shipmentId int32
	shipbobChannelId *int32
}

func (r ApiShipmentShipmentIdTimelineGetRequest) ShipbobChannelId(shipbobChannelId int32) ApiShipmentShipmentIdTimelineGetRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiShipmentShipmentIdTimelineGetRequest) Execute() ([]ShipBobOrdersPresentationViewModelsShipmentLogViewModel, *_nethttp.Response, error) {
	return r.ApiService.ShipmentShipmentIdTimelineGetExecute(r)
}

/*
 * ShipmentShipmentIdTimelineGet Get one Shipment's status timeline by Shipment Id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param shipmentId The shipment id to get
 * @return ApiShipmentShipmentIdTimelineGetRequest
 */
func (a *OrdersApiService) ShipmentShipmentIdTimelineGet(ctx _context.Context, shipmentId int32) ApiShipmentShipmentIdTimelineGetRequest {
	return ApiShipmentShipmentIdTimelineGetRequest{
		ApiService: a,
		ctx: ctx,
		shipmentId: shipmentId,
	}
}

/*
 * Execute executes the request
 * @return []ShipBobOrdersPresentationViewModelsShipmentLogViewModel
 */
func (a *OrdersApiService) ShipmentShipmentIdTimelineGetExecute(r ApiShipmentShipmentIdTimelineGetRequest) ([]ShipBobOrdersPresentationViewModelsShipmentLogViewModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ShipBobOrdersPresentationViewModelsShipmentLogViewModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.ShipmentShipmentIdTimelineGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shipment/{shipmentId}/timeline"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", _neturl.PathEscape(parameterToString(r.shipmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		localVarHeaderParams["shipbob_channel_id"] = parameterToString(*r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShippingmethodGetRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	page *int32
	limit *int32
}

func (r ApiShippingmethodGetRequest) Page(page int32) ApiShippingmethodGetRequest {
	r.page = &page
	return r
}
func (r ApiShippingmethodGetRequest) Limit(limit int32) ApiShippingmethodGetRequest {
	r.limit = &limit
	return r
}

func (r ApiShippingmethodGetRequest) Execute() ([]ShipBobOrdersPresentationViewModelsShipMethodDetailViewModel, *_nethttp.Response, error) {
	return r.ApiService.ShippingmethodGetExecute(r)
}

/*
 * ShippingmethodGet Get shipping methods
 * Get all merchants shipping methods
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiShippingmethodGetRequest
 */
func (a *OrdersApiService) ShippingmethodGet(ctx _context.Context) ApiShippingmethodGetRequest {
	return ApiShippingmethodGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []ShipBobOrdersPresentationViewModelsShipMethodDetailViewModel
 */
func (a *OrdersApiService) ShippingmethodGetExecute(r ApiShippingmethodGetRequest) ([]ShipBobOrdersPresentationViewModelsShipMethodDetailViewModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ShipBobOrdersPresentationViewModelsShipMethodDetailViewModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.ShippingmethodGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shippingmethod"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("Page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("Limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

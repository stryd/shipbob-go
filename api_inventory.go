/*
ShipBob Developer API

ShipBob Developer API Documentation

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package shipbob

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// InventoryApiService InventoryApi service
type InventoryApiService service

type ApiGetInventoriesRequest struct {
	ctx context.Context
	ApiService *InventoryApiService
	page *int32
	limit *int32
	isActive *bool
	isDigital *bool
	iDs *[]int32
	sort *string
	search *string
	shipbobChannelId *int32
}

// Page of inventory items to get
func (r ApiGetInventoriesRequest) Page(page int32) ApiGetInventoriesRequest {
	r.page = &page
	return r
}

// Amount of inventory items per page to request
func (r ApiGetInventoriesRequest) Limit(limit int32) ApiGetInventoriesRequest {
	r.limit = &limit
	return r
}

// Whether the inventory should be active or not
func (r ApiGetInventoriesRequest) IsActive(isActive bool) ApiGetInventoriesRequest {
	r.isActive = &isActive
	return r
}

// Whether the inventory is digital or not
func (r ApiGetInventoriesRequest) IsDigital(isDigital bool) ApiGetInventoriesRequest {
	r.isDigital = &isDigital
	return r
}

// Comma separated inventory ids to filter by
func (r ApiGetInventoriesRequest) IDs(iDs []int32) ApiGetInventoriesRequest {
	r.iDs = &iDs
	return r
}

// Sort will default to ascending order for each field.  To sort in descending order please pass a \&quot;-\&quot; in front of the field name.  For example, Sort&#x3D;-onHand,name will sort by onHand descending
func (r ApiGetInventoriesRequest) Sort(sort string) ApiGetInventoriesRequest {
	r.sort = &sort
	return r
}

// Search is available for 2 fields, Inventory ID and Name - 1. Expected behavior for search by Inventory ID is exact match 2. Expected behavior for search by Inventory Name is partial match, i.e. does not have to be start of word,  but must be consecutive characters. This is not case sensitive.
func (r ApiGetInventoriesRequest) Search(search string) ApiGetInventoriesRequest {
	r.search = &search
	return r
}

// Channel Id for Operation
func (r ApiGetInventoriesRequest) ShipbobChannelId(shipbobChannelId int32) ApiGetInventoriesRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiGetInventoriesRequest) Execute() ([]Inventory, *http.Response, error) {
	return r.ApiService.GetInventoriesExecute(r)
}

/*
GetInventories List inventory items

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetInventoriesRequest
*/
func (a *InventoryApiService) GetInventories(ctx context.Context) ApiGetInventoriesRequest {
	return ApiGetInventoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Inventory
func (a *InventoryApiService) GetInventoriesExecute(r ApiGetInventoriesRequest) ([]Inventory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Inventory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryApiService.GetInventories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Limit", r.limit, "")
	}
	if r.isActive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsActive", r.isActive, "")
	}
	if r.isDigital != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsDigital", r.isDigital, "")
	}
	if r.iDs != nil {
		t := *r.iDs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "IDs", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "IDs", t, "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Sort", r.sort, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Search", r.search, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "shipbob_channel_id", r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInventoryRequest struct {
	ctx context.Context
	ApiService *InventoryApiService
	inventoryId int32
}

func (r ApiGetInventoryRequest) Execute() (*Inventory, *http.Response, error) {
	return r.ApiService.GetInventoryExecute(r)
}

/*
GetInventory Get an inventory item

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param inventoryId The inventory id to get
 @return ApiGetInventoryRequest
*/
func (a *InventoryApiService) GetInventory(ctx context.Context, inventoryId int32) ApiGetInventoryRequest {
	return ApiGetInventoryRequest{
		ApiService: a,
		ctx: ctx,
		inventoryId: inventoryId,
	}
}

// Execute executes the request
//  @return Inventory
func (a *InventoryApiService) GetInventoryExecute(r ApiGetInventoryRequest) (*Inventory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Inventory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryApiService.GetInventory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory/{inventoryId}"
	localVarPath = strings.Replace(localVarPath, "{"+"inventoryId"+"}", url.PathEscape(parameterValueToString(r.inventoryId, "inventoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProductInventoriesRequest struct {
	ctx context.Context
	ApiService *InventoryApiService
	productId int32
	shipbobChannelId *int32
}

// Channel Id for Operation
func (r ApiGetProductInventoriesRequest) ShipbobChannelId(shipbobChannelId int32) ApiGetProductInventoriesRequest {
	r.shipbobChannelId = &shipbobChannelId
	return r
}

func (r ApiGetProductInventoriesRequest) Execute() ([]Inventory, *http.Response, error) {
	return r.ApiService.GetProductInventoriesExecute(r)
}

/*
GetProductInventories Get a list of inventory items by product id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param productId The product id to get inventory for
 @return ApiGetProductInventoriesRequest
*/
func (a *InventoryApiService) GetProductInventories(ctx context.Context, productId int32) ApiGetProductInventoriesRequest {
	return ApiGetProductInventoriesRequest{
		ApiService: a,
		ctx: ctx,
		productId: productId,
	}
}

// Execute executes the request
//  @return []Inventory
func (a *InventoryApiService) GetProductInventoriesExecute(r ApiGetProductInventoriesRequest) ([]Inventory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Inventory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryApiService.GetProductInventories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product/{productId}/inventory"
	localVarPath = strings.Replace(localVarPath, "{"+"productId"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shipbobChannelId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "shipbob_channel_id", r.shipbobChannelId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string][]string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
